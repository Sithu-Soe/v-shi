package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/base64"
	"fmt"
	"image"
	"image/jpeg"
	"image/png"
	"log"
	"os"
	"path/filepath"
	"v-shi/cmd/back/graph/model"
	"v-shi/pkg/dto"
	"v-shi/pkg/miio"
	"v-shi/pkg/models"
	"v-shi/pkg/utils"

	"github.com/anthonynsimon/bild/transform"
	"github.com/jinzhu/copier"
	minio "github.com/minio/minio-go/v7"
	"gorm.io/gorm"
)

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, name string) (*string, error) {
	category := models.Category{
		Name: name,
	}
	if err := r.Repo.Category.Create(ctx, &category); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil

	// resp := model.Category{}

	// if err := copier.CopyWithOption(&resp, &category, copier.Option{
	// 	IgnoreEmpty: false,
	// 	DeepCopy:    true,
	// 	// Converters: []copier.TypeConverter{
	// 	// 	{
	// 	// 		SrcType: time.Time{},
	// 	// 		DstType: copier.String,
	// 	// 		Fn: func(src interface{}) (interface{}, error) {
	// 	// 			s, ok := src.(time.Time)

	// 	// 			if !ok {
	// 	// 				return nil, errors.New("src type not matching")
	// 	// 			}

	// 	// 			return s.Format(time.RFC3339), nil
	// 	// 		},
	// 	// 	},
	// 	// },
	// }); err != nil {
	// 	return nil, err
	// }

	// return &resp, nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, input model.UpdateCategory) (*string, error) {
	if err := r.Repo.Category.UpdateByFields(ctx, &models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data: map[string]any{
			"name": input.Name,
		},
	}); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteCategories is the resolver for the deleteCategories field.
func (r *mutationResolver) DeleteCategories(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)
	return nil, r.Repo.Category.DeleteMany(ctx, idsStr)
}

// CreateShopOwner is the resolver for the createShopOwner field.
func (r *mutationResolver) CreateShopOwner(ctx context.Context, input model.CreateShopOwner) (*string, error) {
	hashedPassword, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, err
	}
	shopOwner := &models.ShopOwner{
		Name:     input.Name,
		Email:    input.Email,
		Password: hashedPassword,
	}

	if err := r.Repo.ShopOwner.Create(ctx, shopOwner); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// UpdateShopOwner is the resolver for the updateShopOwner field.
func (r *mutationResolver) UpdateShopOwner(ctx context.Context, input model.UpdateShopOwner) (*string, error) {
	updateFields := models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data:  map[string]any{},
	}

	if input.Email != nil {
		updateFields.Data["email"] = input.Email
	}

	if input.Name != nil {
		updateFields.Data["name"] = input.Name
	}

	if input.Password != nil {
		hashedPassword, err := utils.HashPassword(*input.Password)
		if err != nil {
			return nil, err
		}
		updateFields.Data["password"] = hashedPassword
	}

	if err := r.Repo.ShopOwner.UpdateByFields(ctx, &updateFields); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteShopOwners is the resolver for the deleteShopOwners field.
func (r *mutationResolver) DeleteShopOwners(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)
	return nil, r.Repo.ShopOwner.DeleteMany(ctx, idsStr)
}

// CreateShop is the resolver for the createShop field.
func (r *mutationResolver) CreateShop(ctx context.Context, input model.CreateShop) (*string, error) {
	ext := filepath.Ext(input.File.Filename)
	filename := utils.GenerateUniqueCode("S") + ext
	fullPath := miio.ShopImagePath + filename

	fileSize := input.File.Size
	if fileSize > miio.MaxImgSize {
		return nil, fmt.Errorf("image file too large")
	}

	var img image.Image
	var err error
	switch input.File.ContentType {
	case "image/jpeg":
		img, err = jpeg.Decode(input.File.File)
		if err != nil {
			return nil, err
		}
	case "image/png":
		img, err = png.Decode(input.File.File)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("unsupported file")
	}

	newImg := transform.Resize(img, 400, 400, transform.Gaussian)

	buf := new(bytes.Buffer)
	if err := jpeg.Encode(buf, newImg, nil); err != nil {
		return nil, err
	}

	_, err = miio.MinioClient.PutObject(ctx, miio.BucketName, fullPath, buf, int64(buf.Len()), minio.PutObjectOptions{})
	if err != nil {
		return nil, err
	}

	shop := &models.Shop{
		Name:         input.Name,
		LogoFilename: filename,
		ShopOwnerID:  uint64(input.ShopOwnerID),
	}

	if err := r.Repo.Shop.Create(ctx, shop); err != nil {
		if err := miio.MinioClient.RemoveObject(ctx, miio.BucketName, fullPath, minio.RemoveObjectOptions{}); err != nil {
			return nil, err
		}
		return nil, err
	}

	return utils.NewString("success"), nil
}

// UpdateShop is the resolver for the updateShop field.
func (r *mutationResolver) UpdateShop(ctx context.Context, input model.UpdateShop) (*string, error) {
	updateFields := models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data:  map[string]any{},
	}

	if input.Name != nil {
		updateFields.Data["name"] = input.Name
	}

	if input.ShopOwnerID != nil {
		updateFields.Data["shop_owner_id"] = input.ShopOwnerID
	}

	if err := r.Repo.Shop.UpdateByFields(ctx, &updateFields); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteShops is the resolver for the deleteShops field.
func (r *mutationResolver) DeleteShops(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)

	return nil, r.Repo.Shop.DeleteMany(ctx, idsStr)
}

// CreateShopLocation is the resolver for the createShopLocation field.
func (r *mutationResolver) CreateShopLocation(ctx context.Context, input model.CreateShopLocation) (*string, error) {
	shopLocation := &models.ShopLocation{
		Name:   input.Name,
		Lat:    input.Lat,
		Lng:    input.Lng,
		ShopID: uint64(input.ShopID),
	}
	if input.Description != nil {
		shopLocation.Description = sql.NullString{
			String: *input.Description,
			Valid:  true,
		}
	}

	if err := r.Repo.Shop.CreateShopLocation(ctx, shopLocation); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// UpdateShopLocation is the resolver for the updateShopLocation field.
func (r *mutationResolver) UpdateShopLocation(ctx context.Context, input model.UpdateShopLocation) (*string, error) {
	updateFields := models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data:  map[string]any{},
	}

	if input.Name != nil {
		updateFields.Data["name"] = input.Name
	}

	if input.Description != nil {
		updateFields.Data["description"] = input.Description
	}

	if input.Lat != nil {
		updateFields.Data["lat"] = input.Lat
	}

	if input.Lng != nil {
		updateFields.Data["lng"] = input.Lng
	}

	if input.ShopID != nil {
		updateFields.Data["shop_id"] = input.ShopID
	}

	if err := r.Repo.Shop.UpdateByFieldsShopLocation(ctx, &updateFields); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteShopLocations is the resolver for the deleteShopLocations field.
func (r *mutationResolver) DeleteShopLocations(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)

	return nil, r.Repo.Shop.DeleteManyShopLocations(ctx, idsStr)
}

// CreateFood is the resolver for the createFood field.
func (r *mutationResolver) CreateFood(ctx context.Context, input model.CreateFood) (*string, error) {
	if len(input.CategoryIds) != 0 {
		total, err := r.Repo.Category.Count(ctx, utils.IdsIntToInCon(input.CategoryIds))
		if err != nil {
			return nil, err
		}

		log.Println(total)

		if int(total) != len(input.CategoryIds) {
			return nil, fmt.Errorf("invalid category id")
		}
	}

	food := models.Food{
		Name:   input.Name,
		ShopID: uint64(input.ShopID),
	}

	if input.Description != nil {
		food.Description = *input.Description
	}

	categories := make([]*models.Category, 0)
	for _, v := range input.CategoryIds {
		categories = append(categories, &models.Category{
			Model: gorm.Model{
				ID: uint(v),
			},
		})
	}

	if err := r.Repo.Food.CreateWithCategories(ctx, &food, categories); err != nil {
		return nil, err
	}

	return nil, nil
}

// UpdateFood is the resolver for the updateFood field.
func (r *mutationResolver) UpdateFood(ctx context.Context, input model.UpdateFood) (*string, error) {
	categories := make([]*models.Category, 0)
	if len(input.CategoryIds) > 0 {
		for _, id := range input.CategoryIds {
			categories = append(categories, &models.Category{
				Model: gorm.Model{
					ID: uint(*id),
				},
			})
		}
	}

	updateFields := models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data:  map[string]any{},
	}
	if input.Name != nil {
		updateFields.Data["name"] = input.Name
	}

	if input.Description != nil {
		updateFields.Data["description"] = input.Description
	}

	if input.ShopID != nil {
		updateFields.Data["shop_id"] = input.ShopID
	}

	if err := r.Repo.Food.Update(ctx, &updateFields, categories); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteFoods is the resolver for the deleteFoods field.
func (r *mutationResolver) DeleteFoods(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)
	// return nil, r.Repo.Food.DeleteMany(ctx, idsStr)
	return nil, r.Repo.Food.DeleteFoodWithCategories(ctx, idsStr)
}

// UploadFoodImages is the resolver for the uploadFoodImages field.
func (r *mutationResolver) UploadFoodImages(ctx context.Context, input []*model.UploadImage) (*string, error) {
	filesInfo := make([]*dto.FileUploadInfo, 0)

	for _, food := range input {
		ext := filepath.Ext(food.File.Filename)
		filename := utils.GenerateUniqueCode("F") + ext
		fullPath := miio.FoodImagePath + filename

		filesInfo = append(filesInfo, &dto.FileUploadInfo{
			ID:       uint64(food.ID),
			FullPath: fullPath,
			Filename: filename,
		})
		if err := utils.UploadImageWithGQL(ctx, fullPath, &food.File); err != nil {
			return nil, err
		}
	}

	foodImages := make([]*models.FoodImage, 0)
	for _, info := range filesInfo {
		foodImages = append(foodImages, &models.FoodImage{
			Filename: info.Filename,
			FoodID:   info.ID,
		})
	}

	if err := r.Repo.Food.CreateFoodImages(ctx, foodImages); err != nil {
		for _, info := range filesInfo {
			if err := miio.MinioClient.RemoveObject(ctx, miio.BucketName, info.FullPath, minio.RemoveObjectOptions{}); err != nil {
				return nil, err
			}
		}
		return nil, err
	}

	return utils.NewString("success"), nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, input model.FilterCategory) (*model.CategoryListResp, error) {
	categories, total, err := r.Repo.Category.FindAll(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.Category, 0)
	if err := copier.Copy(&list, &categories); err != nil {
		return nil, err
	}

	return &model.CategoryListResp{
		List:  list,
		Total: int(total),
	}, nil
}

// ShopOwners is the resolver for the ShopOwners field.
func (r *queryResolver) ShopOwners(ctx context.Context, input model.FilterShopOwner) (*model.ShopOwnerListResponse, error) {
	shopOwners, total, err := r.Repo.ShopOwner.FindAll(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.ShopOwner, 0)
	if err := copier.Copy(&list, &shopOwners); err != nil {
		return nil, err
	}

	return &model.ShopOwnerListResponse{
		List:  list,
		Total: int(total),
	}, nil
}

// Shops is the resolver for the shops field.
func (r *queryResolver) Shops(ctx context.Context, input model.FilterShop) (*model.ShopListResp, error) {
	shops, total, err := r.Repo.Shop.FindAll(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.Shop, 0)
	if err := copier.Copy(&list, &shops); err != nil {
		return nil, err
	}

	return &model.ShopListResp{
		List:  list,
		Total: int(total),
	}, nil
}

// ShopLocations is the resolver for the shopLocations field.
func (r *queryResolver) ShopLocations(ctx context.Context, input model.FilterShopLocation) (*model.ShopLocationListResp, error) {
	shopLocations, total, err := r.Repo.Shop.FindAllShopLocations(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.ShopLocation, 0)
	if err := copier.Copy(&list, &shopLocations); err != nil {
		return nil, err
	}

	return &model.ShopLocationListResp{
		List:  list,
		Total: int(total),
	}, nil
}

// Foods is the resolver for the foods field.
func (r *queryResolver) Foods(ctx context.Context, input model.FilterFood) (*model.FoodListResponse, error) {
	foods, total, err := r.Repo.Food.FindAll(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.Food, 0)
	if err := copier.Copy(&list, &foods); err != nil {
		return nil, err
	}

	return &model.FoodListResponse{
		List:  list,
		Total: int(total),
	}, nil
}

// FileLogo is the resolver for the FileLogo field.
func (r *queryResolver) FileLogo(ctx context.Context, logoFilename string) (string, error) {
	filePath := fmt.Sprintf("shop/images/%v", logoFilename)

	// if err := miio.MinioClient.FGetObject(ctx, miio.BucketName, logoFilename, "shop/images", minio.GetObjectOptions{}); err != nil {
	// 	return "", err
	// }

	bytes, err := os.ReadFile(filePath)
	if err != nil {
		return "", err
	}

	var base64Encoding string

	mimeType, err := utils.SniffContentTypeFromFile(filePath)
	if err != nil {
		return "", err
	}
	// Prepend the appropriate URI scheme header depending
	// on the MIME type
	// switch mimeType {
	// case "image/jpeg":
	// 	base64Encoding += "data:image/jpeg;base64,"
	// case "image/png":
	// 	base64Encoding += "data:image/png;base64,"
	// }
	base64Encoding += fmt.Sprintf("data:%v;base64", mimeType)

	// Append the base64 encoded output
	return base64Encoding + base64.StdEncoding.EncodeToString(bytes), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
