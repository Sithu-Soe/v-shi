package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/base64"
	"fmt"
	"image"
	"image/jpeg"
	"image/png"
	"log"
	"os"
	"path/filepath"
	"v-shi/cmd/back/graph/model"
	"v-shi/pkg/miio"
	"v-shi/pkg/models"
	"v-shi/pkg/utils"

	"github.com/anthonynsimon/bild/transform"
	"github.com/jinzhu/copier"
	minio "github.com/minio/minio-go/v7"
)

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, name string) (*model.Category, error) {
	category := models.Category{
		Name: name,
	}
	if err := r.Repo.Category.Create(ctx, &category); err != nil {
		return nil, err
	}

	resp := model.Category{}

	if err := copier.CopyWithOption(&resp, &category, copier.Option{
		IgnoreEmpty: false,
		DeepCopy:    true,
		// Converters: []copier.TypeConverter{
		// 	{
		// 		SrcType: time.Time{},
		// 		DstType: copier.String,
		// 		Fn: func(src interface{}) (interface{}, error) {
		// 			s, ok := src.(time.Time)

		// 			if !ok {
		// 				return nil, errors.New("src type not matching")
		// 			}

		// 			return s.Format(time.RFC3339), nil
		// 		},
		// 	},
		// },
	}); err != nil {
		return nil, err
	}

	return &resp, nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, input model.UpdateCategory) (*string, error) {
	err := r.Repo.Category.UpdateByFields(ctx, &models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data: map[string]any{
			"name": input.Name,
		},
	})
	return nil, err
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, input int) (*string, error) {
	panic(fmt.Errorf("not implemented: DeleteCategory - deleteCategory"))
}

// CreateShopOwner is the resolver for the createShopOwner field.
func (r *mutationResolver) CreateShopOwner(ctx context.Context, input model.CreateShopOwner) (*string, error) {
	hashedPassword, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, err
	}
	shopOwner := &models.ShopOwner{
		Name:     input.Name,
		Email:    input.Email,
		Password: hashedPassword,
	}

	if err := r.Repo.ShopOwner.Create(ctx, shopOwner); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// UpdateShopOwner is the resolver for the updateShopOwner field.
func (r *mutationResolver) UpdateShopOwner(ctx context.Context, input model.UpdateShopOwner) (*string, error) {
	updateFields := models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data:  map[string]any{},
	}

	if input.Email != nil {
		updateFields.Data["email"] = input.Email
	}

	if input.Name != nil {
		updateFields.Data["name"] = input.Name
	}

	if input.Password != nil {
		hashedPassword, err := utils.HashPassword(*input.Password)
		if err != nil {
			return nil, err
		}
		updateFields.Data["password"] = hashedPassword
	}

	if err := r.Repo.ShopOwner.UpdateByFields(ctx, &updateFields); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteShopOwners is the resolver for the deleteShopOwners field.
func (r *mutationResolver) DeleteShopOwners(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)
	return nil, r.Repo.ShopOwner.DeleteMany(ctx, idsStr)
}

// CreateShop is the resolver for the createShop field.
func (r *mutationResolver) CreateShop(ctx context.Context, input model.CreateShop) (*string, error) {
	ext := filepath.Ext(input.File.Filename)
	filename := utils.GenerateUniqueCode("S") + ext
	fullPath := "shop/images/" + filename

	fileSize := input.File.Size
	if fileSize > miio.MaxImgSize {
		return nil, fmt.Errorf("image file too large")
	}

	var img image.Image
	var err error
	switch input.File.ContentType {
	case "image/jpeg":
		img, err = jpeg.Decode(input.File.File)
		if err != nil {
			log.Println(err)
			return nil, err
		}
	case "image/png":
		img, err = png.Decode(input.File.File)
		if err != nil {
			log.Println(err)
			return nil, err
		}
	default:
		return nil, fmt.Errorf("unsupported file")
	}

	newImg := transform.Resize(img, 400, 400, transform.Gaussian)

	buf := new(bytes.Buffer)
	if err := jpeg.Encode(buf, newImg, nil); err != nil {
		return nil, err
	}

	_, err = miio.MinioClient.PutObject(ctx, miio.BucketName, fullPath, buf, int64(buf.Len()), minio.PutObjectOptions{})
	if err != nil {
		log.Println(err)
		return nil, err
	}

	shop := &models.Shop{
		Name:         input.Name,
		LogoFilename: filename,
		ShopOwnerID:  uint64(input.ShopOwnerID),
	}

	if err := r.Repo.Shop.Create(ctx, shop); err != nil {
		if err := miio.MinioClient.RemoveObject(ctx, miio.BucketName, fullPath, minio.RemoveObjectOptions{}); err != nil {
			return nil, err
		}
		return nil, err
	}

	return utils.NewString("success"), nil
}

// UpdateShop is the resolver for the updateShop field.
func (r *mutationResolver) UpdateShop(ctx context.Context, input model.UpdateShop) (*string, error) {
	updateFields := models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data:  map[string]any{},
	}

	if input.Name != nil {
		updateFields.Data["name"] = input.Name
	}

	if input.ShopOwnerID != nil {
		updateFields.Data["shop_owner_id"] = input.ShopOwnerID
	}

	if err := r.Repo.Shop.UpdateByFields(ctx, &updateFields); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteShops is the resolver for the deleteShops field.
func (r *mutationResolver) DeleteShops(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)

	return nil, r.Repo.Shop.DeleteMany(ctx, idsStr)
}

// CreateShopLocation is the resolver for the createShopLocation field.
func (r *mutationResolver) CreateShopLocation(ctx context.Context, input model.CreateShopLocation) (*string, error) {
	shopLocation := &models.ShopLocation{
		Name:   input.Name,
		Lat:    input.Lat,
		Lng:    input.Lng,
		ShopID: uint64(input.ShopID),
	}
	if input.Description != nil {
		shopLocation.Description = sql.NullString{
			String: *input.Description,
			Valid:  true,
		}
	}

	if err := r.Repo.Shop.CreateShopLocation(ctx, shopLocation); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// UpdateShopLocation is the resolver for the updateShopLocation field.
func (r *mutationResolver) UpdateShopLocation(ctx context.Context, input model.UpdateShopLocation) (*string, error) {
	updateFields := models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data:  map[string]any{},
	}

	if input.Name != nil {
		updateFields.Data["name"] = input.Name
	}

	if input.Description != nil {
		updateFields.Data["description"] = input.Description
	}

	if input.Lat != nil {
		updateFields.Data["lat"] = input.Lat
	}

	if input.Lng != nil {
		updateFields.Data["lng"] = input.Lng
	}

	if input.ShopID != nil {
		updateFields.Data["shop_id"] = input.ShopID
	}

	if err := r.Repo.Shop.UpdateByFieldsShopLocation(ctx, &updateFields); err != nil {
		return nil, err
	}

	return utils.NewString("success"), nil
}

// DeleteShopLocations is the resolver for the deleteShopLocations field.
func (r *mutationResolver) DeleteShopLocations(ctx context.Context, ids []int) (*string, error) {
	idsStr := utils.IdsIntToInCon(ids)

	return nil, r.Repo.Shop.DeleteManyShopLocations(ctx, idsStr)
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	return r.Repo.Category.FindByField(ctx, "id", id)
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, input model.FilterCategory) (*model.CategoryListResp, error) {
	categories, total, err := r.Repo.Category.All(ctx, &input)
	if err != nil {
		return nil, err
	}
	return &model.CategoryListResp{
		List:  categories,
		Total: int(total),
	}, nil
}

// CategoryWithShop is the resolver for the categoryWithShop field.
func (r *queryResolver) CategoryWithShop(ctx context.Context, id int) (*model.CategoryWithFoods, error) {
	panic(fmt.Errorf("not implemented: CategoryWithShop - categoryWithShop"))
}

// CategoriesWithShops is the resolver for the categoriesWithShops field.
func (r *queryResolver) CategoriesWithShops(ctx context.Context, input *model.FilterCategory) (*model.CategoryWithFoodsListResp, error) {
	panic(fmt.Errorf("not implemented: CategoriesWithShops - categoriesWithShops"))
}

// ShopOwners is the resolver for the ShopOwners field.
func (r *queryResolver) ShopOwners(ctx context.Context, input model.FilterShopOwner) (*model.ShopOwnerListResponse, error) {
	shopOwners, total, err := r.Repo.ShopOwner.FindAll(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.ShopOwner, 0)
	if err := copier.Copy(&list, &shopOwners); err != nil {
		log.Println(err, "DD")
		return nil, err
	}

	return &model.ShopOwnerListResponse{
		List:  list,
		Total: int(total),
	}, nil
}

// Shops is the resolver for the shops field.
func (r *queryResolver) Shops(ctx context.Context, input model.FilterShop) (*model.ShopListResp, error) {
	shops, total, err := r.Repo.Shop.FindAll(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.Shop, 0)
	if err := copier.Copy(&list, &shops); err != nil {
		return nil, err
	}

	return &model.ShopListResp{
		List:  list,
		Total: int(total),
	}, nil
}

// ShopLocations is the resolver for the shopLocations field.
func (r *queryResolver) ShopLocations(ctx context.Context, input model.FilterShopLocation) (*model.ShopLocationListResp, error) {
	shopLocations, total, err := r.Repo.Shop.FindAllShopLocations(ctx, &input)
	if err != nil {
		return nil, err
	}

	list := make([]*model.ShopLocation, 0)
	if err := copier.Copy(&list, &shopLocations); err != nil {
		return nil, err
	}

	return &model.ShopLocationListResp{
		List:  list,
		Total: int(total),
	}, nil
}

// FileLogo is the resolver for the FileLogo field.
func (r *queryResolver) FileLogo(ctx context.Context, logoFilename string) (string, error) {
	filePath := fmt.Sprintf("shop/images/%v", logoFilename)

	// if err := miio.MinioClient.FGetObject(ctx, miio.BucketName, logoFilename, "shop/images", minio.GetObjectOptions{}); err != nil {
	// 	return "", err
	// }

	bytes, err := os.ReadFile(filePath)
	if err != nil {
		return "", err
	}

	var base64Encoding string

	mimeType, err := utils.SniffContentTypeFromFile(filePath)
	if err != nil {
		return "", err
	}
	// Prepend the appropriate URI scheme header depending
	// on the MIME type
	// switch mimeType {
	// case "image/jpeg":
	// 	base64Encoding += "data:image/jpeg;base64,"
	// case "image/png":
	// 	base64Encoding += "data:image/png;base64,"
	// }
	base64Encoding += fmt.Sprintf("data:%v;base64", mimeType)

	// Append the base64 encoded output
	return base64Encoding + base64.StdEncoding.EncodeToString(bytes), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) Shop(ctx context.Context, id int) (*model.Shop, error) {
	panic(fmt.Errorf("not implemented: Shop - shop"))
}
func (r *mutationResolver) DeleteShop(ctx context.Context, ids []int) (*string, error) {
	panic(fmt.Errorf("not implemented: DeleteShop - deleteShop"))
}
func (r *mutationResolver) DeleteShopOwner(ctx context.Context, id int) (*string, error) {
	panic(fmt.Errorf("not implemented: DeleteShopOwner - deleteShopOwner"))
}
