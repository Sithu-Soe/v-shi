package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"image"
	"image/jpeg"
	"image/png"
	"log"
	"os"
	"path/filepath"
	"v-shi/cmd/back/graph/model"
	"v-shi/pkg/miio"
	"v-shi/pkg/models"
	"v-shi/pkg/utils"

	"github.com/anthonynsimon/bild/transform"

	"github.com/jinzhu/copier"
	minio "github.com/minio/minio-go/v7"
)

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, name string) (*model.Category, error) {
	category := models.Category{
		Name: name,
	}
	if err := r.Repo.Category.Create(ctx, &category); err != nil {
		return nil, err
	}

	resp := model.Category{}

	if err := copier.CopyWithOption(&resp, &category, copier.Option{
		IgnoreEmpty: false,
		DeepCopy:    true,
		// Converters: []copier.TypeConverter{
		// 	{
		// 		SrcType: time.Time{},
		// 		DstType: copier.String,
		// 		Fn: func(src interface{}) (interface{}, error) {
		// 			s, ok := src.(time.Time)

		// 			if !ok {
		// 				return nil, errors.New("src type not matching")
		// 			}

		// 			return s.Format(time.RFC3339), nil
		// 		},
		// 	},
		// },
	}); err != nil {
		return nil, err
	}

	return &resp, nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, input model.UpdateCategory) (*string, error) {
	err := r.Repo.Category.UpdateByFields(ctx, &models.UpdateFields{
		Field: "id",
		Value: input.ID,
		Data: map[string]any{
			"name": input.Name,
		},
	})
	return nil, err
}

// CreateShop is the resolver for the createShop field.
func (r *mutationResolver) CreateShop(ctx context.Context, input model.CreateShop) (*model.Shop, error) {
	ext := filepath.Ext(input.File.Filename)
	filename := utils.GenerateUniqueCode("S") + ext
	fullPath := "shop/images/" + filename

	fileSize := input.File.Size
	if fileSize > miio.MaxImgSize {
		return nil, fmt.Errorf("image file too large")
	}

	var img image.Image
	var err error
	switch input.File.ContentType {
	case "image/jpeg":
		img, err = jpeg.Decode(input.File.File)
		if err != nil {
			log.Println(err)
			return nil, err
		}
	case "image/png":
		img, err = png.Decode(input.File.File)
		if err != nil {
			log.Println(err)
			return nil, err
		}
	default:
		return nil, fmt.Errorf("unsupported file")
	}

	newImg := transform.Resize(img, 400, 400, transform.Gaussian)

	buf := new(bytes.Buffer)
	if err := jpeg.Encode(buf, newImg, nil); err != nil {
		return nil, err
	}

	_, err = miio.MinioClient.PutObject(ctx, miio.BucketName, fullPath, buf, int64(buf.Len()), minio.PutObjectOptions{})
	if err != nil {
		log.Println(err)
		return nil, err
	}

	shop := &models.Shop{
		Name:         input.Name,
		LogoFilename: filename,
	}
	if err := r.Repo.Shop.Create(ctx, shop); err != nil {
		return nil, err
	}
	resp := model.Shop{}
	if err := copier.Copy(&resp, shop); err != nil {
		return nil, err
	}

	return &resp, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	return r.Repo.Category.FindByField(ctx, "id", id)
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, input model.FilterCatrgory) (*model.CategoriesResp, error) {
	categories, total, err := r.Repo.Category.All(ctx, &input)
	if err != nil {
		return nil, err
	}
	return &model.CategoriesResp{
		List:  categories,
		Total: int(total),
	}, nil
}

// Shop is the resolver for the shop field.
func (r *queryResolver) Shop(ctx context.Context, id int) (*model.Shop, error) {
	panic(fmt.Errorf("not implemented: Shop - shop"))
}

// Shops is the resolver for the shops field.
func (r *queryResolver) Shops(ctx context.Context, input *model.FilterShop) (*model.ShopsResp, error) {
	panic(fmt.Errorf("not implemented: Shops - shops"))
}

// FileLogo is the resolver for the FileLogo field.
func (r *queryResolver) FileLogo(ctx context.Context, logoFilename string) (string, error) {
	filePath := fmt.Sprintf("shop/images/%v", logoFilename)

	// if err := miio.MinioClient.FGetObject(ctx, miio.BucketName, logoFilename, "shop/images", minio.GetObjectOptions{}); err != nil {
	// 	return "", err
	// }

	bytes, err := os.ReadFile(filePath)
	if err != nil {
		return "", err
	}

	var base64Encoding string

	mimeType, err := utils.SniffContentTypeFromFile(filePath)
	if err != nil {
		return "", err
	}
	// Prepend the appropriate URI scheme header depending
	// on the MIME type
	// switch mimeType {
	// case "image/jpeg":
	// 	base64Encoding += "data:image/jpeg;base64,"
	// case "image/png":
	// 	base64Encoding += "data:image/png;base64,"
	// }
	base64Encoding += fmt.Sprintf("data:%v;base64", mimeType)

	// Append the base64 encoded output
	return base64Encoding + base64.StdEncoding.EncodeToString(bytes), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
